<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Merge Numbers - Fluid Motion</title>
    <style>
        :root {
            --bg-color: #bbada0;
            --cell-color: rgba(238, 228, 218, 0.35);
            --board-size: clamp(280px, 92vw, 400px);
            --grid-gap: 12px;
            --cell-size: calc((var(--board-size) - (var(--grid-gap) * 5)) / 4);
        }

        body {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            min-height: 100vh; margin: 0; background-color: #faf8ef;
            font-family: Arial, sans-serif; touch-action: none; overflow: hidden;
        }

        .header { width: var(--board-size); display: flex; justify-content: space-between; margin-bottom: 10px; }
        .score-box { background: var(--bg-color); color: white; padding: 10px; border-radius: 6px; text-align: center; min-width: 80px; }

        #game-board {
            position: relative; width: var(--board-size); height: var(--board-size);
            background-color: var(--bg-color); border-radius: 6px; padding: var(--grid-gap);
            display: grid; grid-template-columns: repeat(4, 1fr); grid-template-rows: repeat(4, 1fr); grid-gap: var(--grid-gap);
        }

        .grid-cell { width: 100%; height: 100%; background: var(--cell-color); border-radius: 4px; }

        /* 动态生成的方块样式 */
        .tile {
            position: absolute;
            width: var(--cell-size);
            height: var(--cell-size);
            border-radius: 4px;
            display: flex; align-items: center; justify-content: center;
            font-size: 24px; font-weight: bold; color: #776e65;
            z-index: 10;
            transition: transform 0.1s ease-out; /* 用于松手后的回弹或到位 */
            pointer-events: none; /* 防止干扰触摸事件 */
        }

        .n-1 { background-color: #64b5f6; color: white; }
        .n-2 { background-color: #ef5350; color: white; }
        .n-3 { background-color: #ffffff; }
        .n-6 { background-color: #f2b179; color: white; }
        .tile-new { animation: appear 0.2s ease-out; }

        @keyframes appear { 0% { opacity: 0; transform: scale(0.5); } 100% { opacity: 1; transform: scale(1); } }
    </style>
</head>
<body>

    <div class="header">
        <div class="score-box">Next: <span id="next-val">-</span></div>
        <div class="score-box">Score: <span id="score">0</span></div>
    </div>

    <div id="game-board">
        <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
        <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
        <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
        <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
    </div>

    <script>
        const boardContainer = document.getElementById('game-board');
        const nextElement = document.getElementById('next-val');
        const scoreElement = document.getElementById('score');

        let board = Array(16).fill(0);
        let score = 0;
        let nextValue = 1;
        let startX, startY, currentDir = null;
        let isMoving = false;

        // 初始化游戏
        function init() {
            board = Array(16).fill(0);
            score = 0;
            spawn(); spawn();
            render();
        }

        function spawn() {
            let empty = board.map((v, i) => v === 0 ? i : null).filter(v => v !== null);
            if (empty.length > 0) {
                let idx = empty[Math.floor(Math.random() * empty.length)];
                board[idx] = nextValue;
                nextValue = Math.random() > 0.5 ? 1 : 2;
                nextElement.innerText = nextValue;
                nextElement.parentElement.style.backgroundColor = nextValue === 1 ? '#64b5f6' : '#ef5350';
            }
        }

        // 核心渲染逻辑：计算每个方块的绝对位置
        function render() {
            // 清除之前的方块
            document.querySelectorAll('.tile').forEach(t => t.remove());
            board.forEach((val, i) => {
                if (val > 0) {
                    const tile = document.createElement('div');
                    tile.className = `tile n-${val > 6 ? '6' : val}`;
                    tile.innerText = val;
                    tile.id = `tile-${i}`;
                    
                    // 计算基于格子的位置
                    const row = Math.floor(i / 4);
                    const col = i % 4;
                    positionTile(tile, row, col);
                    boardContainer.appendChild(tile);
                }
            });
            scoreElement.innerText = score;
        }

        function positionTile(el, row, col, offsetX = 0, offsetY = 0) {
            const gap = 12; // grid-gap
            const size = el.offsetWidth || (boardContainer.offsetWidth - 60) / 4; 
            // 简单的计算公式定位到背景格中心
            const x = col * (size + gap) + gap;
            const y = row * (size + gap) + gap;
            el.style.transform = `translate(${x + offsetX}px, ${y + offsetY}px)`;
        }

        // 触摸开始
        document.addEventListener('touchstart', e => {
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
            currentDir = null;
            isMoving = true;
            // 关闭所有方块的动画过渡，防止滑动延迟
            document.querySelectorAll('.tile').forEach(t => t.style.transition = 'none');
        }, {passive: false});

        // 触摸移动：实时跟随手指
        document.addEventListener('touchmove', e => {
            if (!isMoving) return;
            const dx = e.touches[0].clientX - startX;
            const dy = e.touches[0].clientY - startY;

            // 确定滑动方向并锁定
            if (!currentDir) {
                if (Math.abs(dx) > 10) currentDir = 'H';
                else if (Math.abs(dy) > 10) currentDir = 'V';
                return;
            }

            e.preventDefault(); // 阻止滚动

            // 限制滑动距离最大为一个格子的大小
            const maxMove = 80; 
            const moveX = currentDir === 'H' ? Math.max(Math.min(dx, maxMove), -maxMove) : 0;
            const moveY = currentDir === 'V' ? Math.max(Math.min(dy, maxMove), -maxMove) : 0;

            // 让所有方块随手指偏移
            board.forEach((val, i) => {
                if (val > 0) {
                    const tile = document.getElementById(`tile-${i}`);
                    if (tile) {
                        const row = Math.floor(i / 4);
                        const col = i % 4;
                        positionTile(tile, row, col, moveX, moveY);
                    }
                }
            });
        }, {passive: false});

        // 触摸结束：判断是合并还是撤回
        document.addEventListener('touchend', e => {
            if (!isMoving) return;
            isMoving = false;
            const dx = e.changedTouches[0].clientX - startX;
            const dy = e.changedTouches[0].clientY - startY;
            const threshold = 50; // 滑动超过50px才触发逻辑

            let direction = null;
            if (currentDir === 'H' && Math.abs(dx) > threshold) direction = dx > 0 ? 'RIGHT' : 'LEFT';
            if (currentDir === 'V' && Math.abs(dy) > threshold) direction = dy > 0 ? 'DOWN' : 'UP';

            if (direction) {
                executeMove(direction);
            } else {
                // 距离不够，撤回原位
                document.querySelectorAll('.tile').forEach(t => t.style.transition = 'transform 0.2s ease-out');
                render(); 
            }
        });

        // 游戏逻辑处理（与之前类似，但触发在松手后）
        function canMerge(a, b) {
            if (a === 0 || b === 0) return false;
            if ((a === 1 && b === 2) || (a === 2 && b === 1)) return true;
            return (a === b && a >= 3);
        }

        function executeMove(dir) {
            let moved = false;
            const isH = dir === 'LEFT' || dir === 'RIGHT';
            const isRev = dir === 'RIGHT' || dir === 'DOWN';

            for (let i = 0; i < 4; i++) {
                let line = [];
                for (let j = 0; j < 4; j++) {
                    line.push(board[isH ? (i * 4 + j) : (j * 4 + i)]);
                }
                if (isRev) line.reverse();

                let filtered = line.filter(v => v !== 0);
                let res = [];
                for (let j = 0; j < filtered.length; j++) {
                    if (j < filtered.length - 1 && canMerge(filtered[j], filtered[j+1])) {
                        res.push(filtered[j] + filtered[j+1]);
                        score += res[res.length-1];
                        j++;
                        moved = true;
                    } else {
                        res.push(filtered[j]);
                    }
                }
                while (res.length < 4) res.push(0);
                if (isRev) res.reverse();

                for (let j = 0; j < 4; j++) {
                    const idx = isH ? (i * 4 + j) : (j * 4 + i);
                    if (board[idx] !== res[j]) moved = true;
                    board[idx] = res[j];
                }
            }

            if (moved) {
                spawn();
            }
            // 增加过渡动画后重新渲染
            document.querySelectorAll('.tile').forEach(t => t.style.transition = 'transform 0.1s ease-out');
            render();
        }

        init();
    </script>
</body>
</html>